/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * TMREV API v2
 * Review aggregation and movie database API
 * OpenAPI spec version: 2.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from '@tanstack/react-query';

import type {
	ActorInsight,
	BatchWatchedDtoClass,
	CreateReviewDtoClass,
	CreateUserDto,
	CreateWatchListDtoClass,
	CreateWatchedDtoClass,
	GenreInsight,
	HeatmapInsight,
	InsightControllerGetHeatmapInsightsParams,
	Movie,
	MovieWatchedStatsDto,
	ReviewAggregated,
	ReviewControllerFindByActorId200,
	ReviewControllerFindByTmdbId200,
	ReviewControllerFindByTmdbIdParams,
	ReviewControllerFindByUserId200,
	ReviewControllerFindByUserIdParams,
	ReviewControllerFindMostReviewedV2200Item,
	UpdateReviewDtoClass,
	UpdateUserDto,
	UpdateWatchListDtoClass,
	UpdateWatchedDtoClass,
	User,
	UserProfileWithWatchedCount,
	UsernameAvailableDto,
	WatchListControllerFindOneParams,
	WatchListControllerGetUserWatchLists200,
	WatchListControllerGetUserWatchListsParams,
	WatchedAggregated,
	WatchedControllerFindByUserId200,
	WatchedControllerFindByUserIdParams,
	WatchedStatusDto,
	Watchlist,
	WatchlistAggregatedDetail,
} from './schemas';

import { axiosInstance } from './mutator/axiosInstance';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const appControllerGetHello = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<void>({ url: `/`, method: 'GET', signal }, options);
};

export const getAppControllerGetHelloQueryKey = () => {
	return [`/`] as const;
};

export const getAppControllerGetHelloQueryOptions = <
	TData = Awaited<ReturnType<typeof appControllerGetHello>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) =>
		appControllerGetHello(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof appControllerGetHello>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AppControllerGetHelloQueryResult = NonNullable<
	Awaited<ReturnType<typeof appControllerGetHello>>
>;
export type AppControllerGetHelloQueryError = unknown;

export function useAppControllerGetHello<
	TData = Awaited<ReturnType<typeof appControllerGetHello>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof appControllerGetHello>>,
					TError,
					Awaited<ReturnType<typeof appControllerGetHello>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAppControllerGetHello<
	TData = Awaited<ReturnType<typeof appControllerGetHello>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof appControllerGetHello>>,
					TError,
					Awaited<ReturnType<typeof appControllerGetHello>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAppControllerGetHello<
	TData = Awaited<ReturnType<typeof appControllerGetHello>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAppControllerGetHello<
	TData = Awaited<ReturnType<typeof appControllerGetHello>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getAppControllerGetHelloQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get recently reviewed movies
 */
export const reviewControllerFindRecentlyReviewed = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated[]>(
		{ url: `/review/recently-reviewed`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindRecentlyReviewedQueryKey = () => {
	return [`/review/recently-reviewed`] as const;
};

export const getReviewControllerFindRecentlyReviewedQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>, TError, TData>
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindRecentlyReviewedQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>
	> = ({ signal }) => reviewControllerFindRecentlyReviewed(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReviewControllerFindRecentlyReviewedQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>
>;
export type ReviewControllerFindRecentlyReviewedQueryError = unknown;

export function useReviewControllerFindRecentlyReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindRecentlyReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindRecentlyReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get recently reviewed movies
 */

export function useReviewControllerFindRecentlyReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getReviewControllerFindRecentlyReviewedQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get most reviewed movies
 */
export const reviewControllerFindMostReviewed = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated[]>(
		{ url: `/review/most-reviewed`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindMostReviewedQueryKey = () => {
	return [`/review/most-reviewed`] as const;
};

export const getReviewControllerFindMostReviewedQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>, TError, TData>
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindMostReviewedQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>> = ({
		signal,
	}) => reviewControllerFindMostReviewed(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReviewControllerFindMostReviewedQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>
>;
export type ReviewControllerFindMostReviewedQueryError = unknown;

export function useReviewControllerFindMostReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindMostReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindMostReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get most reviewed movies
 */

export function useReviewControllerFindMostReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getReviewControllerFindMostReviewedQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Returns the top 10 most reviewed movies with complete review, profile, and movie details. Includes a count of how many times each movie has been reviewed.
 * @summary Get most reviewed movies with full details (v2)
 */
export const reviewControllerFindMostReviewedV2 = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewControllerFindMostReviewedV2200Item[]>(
		{ url: `/review/most-reviewed/v2`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindMostReviewedV2QueryKey = () => {
	return [`/review/most-reviewed/v2`] as const;
};

export const getReviewControllerFindMostReviewedV2QueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>, TError, TData>
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindMostReviewedV2QueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>> = ({
		signal,
	}) => reviewControllerFindMostReviewedV2(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReviewControllerFindMostReviewedV2QueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>
>;
export type ReviewControllerFindMostReviewedV2QueryError = unknown;

export function useReviewControllerFindMostReviewedV2<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindMostReviewedV2<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindMostReviewedV2<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get most reviewed movies with full details (v2)
 */

export function useReviewControllerFindMostReviewedV2<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getReviewControllerFindMostReviewedV2QueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Create a new review
 */
export const reviewControllerCreate = (
	createReviewDtoClass: CreateReviewDtoClass,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated>(
		{
			url: `/review`,
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			data: createReviewDtoClass,
			signal,
		},
		options
	);
};

export const getReviewControllerCreateMutationOptions = <
	TError = void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerCreate>>,
		TError,
		{ data: CreateReviewDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof reviewControllerCreate>>,
	TError,
	{ data: CreateReviewDtoClass },
	TContext
> => {
	const mutationKey = ['reviewControllerCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof reviewControllerCreate>>,
		{ data: CreateReviewDtoClass }
	> = (props) => {
		const { data } = props ?? {};

		return reviewControllerCreate(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReviewControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerCreate>>
>;
export type ReviewControllerCreateMutationBody = CreateReviewDtoClass;
export type ReviewControllerCreateMutationError = void | void;

/**
 * @summary Create a new review
 */
export const useReviewControllerCreate = <TError = void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof reviewControllerCreate>>,
			TError,
			{ data: CreateReviewDtoClass },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof reviewControllerCreate>>,
	TError,
	{ data: CreateReviewDtoClass },
	TContext
> => {
	const mutationOptions = getReviewControllerCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get reviews by TMDB movie ID
 */
export const reviewControllerFindByTmdbId = (
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewControllerFindByTmdbId200>(
		{ url: `/review/tmdb/${tmdbId}`, method: 'GET', params, signal },
		options
	);
};

export const getReviewControllerFindByTmdbIdQueryKey = (
	tmdbId?: number,
	params?: ReviewControllerFindByTmdbIdParams
) => {
	return [`/review/tmdb/${tmdbId}`, ...(params ? [params] : [])] as const;
};

export const getReviewControllerFindByTmdbIdQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
	TError = unknown,
>(
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReviewControllerFindByTmdbIdQueryKey(tmdbId, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>> = ({
		signal,
	}) => reviewControllerFindByTmdbId(tmdbId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!tmdbId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReviewControllerFindByTmdbIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>
>;
export type ReviewControllerFindByTmdbIdQueryError = unknown;

export function useReviewControllerFindByTmdbId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
	TError = unknown,
>(
	tmdbId: number,
	params: undefined | ReviewControllerFindByTmdbIdParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindByTmdbId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
	TError = unknown,
>(
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindByTmdbId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
	TError = unknown,
>(
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get reviews by TMDB movie ID
 */

export function useReviewControllerFindByTmdbId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
	TError = unknown,
>(
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getReviewControllerFindByTmdbIdQueryOptions(tmdbId, params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get reviews by user ID
 */
export const reviewControllerFindByUserId = (
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewControllerFindByUserId200>(
		{ url: `/review/user/${userId}`, method: 'GET', params, signal },
		options
	);
};

export const getReviewControllerFindByUserIdQueryKey = (
	userId?: string,
	params?: ReviewControllerFindByUserIdParams
) => {
	return [`/review/user/${userId}`, ...(params ? [params] : [])] as const;
};

export const getReviewControllerFindByUserIdQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByUserId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReviewControllerFindByUserIdQueryKey(userId, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindByUserId>>> = ({
		signal,
	}) => reviewControllerFindByUserId(userId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReviewControllerFindByUserIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindByUserId>>
>;
export type ReviewControllerFindByUserIdQueryError = unknown;

export function useReviewControllerFindByUserId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params: undefined | ReviewControllerFindByUserIdParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByUserId>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindByUserId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindByUserId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByUserId>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindByUserId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindByUserId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByUserId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get reviews by user ID
 */

export function useReviewControllerFindByUserId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByUserId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getReviewControllerFindByUserIdQueryOptions(userId, params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get reviews by user ID and actor ID
 */
export const reviewControllerFindByActorId = (
	userId: string,
	actorId: number,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewControllerFindByActorId200>(
		{ url: `/review/user/${userId}/actor/${actorId}`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindByActorIdQueryKey = (userId?: string, actorId?: number) => {
	return [`/review/user/${userId}/actor/${actorId}`] as const;
};

export const getReviewControllerFindByActorIdQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
	TError = void,
>(
	userId: string,
	actorId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByActorId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReviewControllerFindByActorIdQueryKey(userId, actorId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindByActorId>>> = ({
		signal,
	}) => reviewControllerFindByActorId(userId, actorId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!(userId && actorId), ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReviewControllerFindByActorIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindByActorId>>
>;
export type ReviewControllerFindByActorIdQueryError = void;

export function useReviewControllerFindByActorId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
	TError = void,
>(
	userId: string,
	actorId: number,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByActorId>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindByActorId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindByActorId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
	TError = void,
>(
	userId: string,
	actorId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByActorId>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindByActorId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindByActorId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
	TError = void,
>(
	userId: string,
	actorId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByActorId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get reviews by user ID and actor ID
 */

export function useReviewControllerFindByActorId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
	TError = void,
>(
	userId: string,
	actorId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindByActorId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getReviewControllerFindByActorIdQueryOptions(userId, actorId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get a review by ID
 */
export const reviewControllerFindOne = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated>({ url: `/review/${id}`, method: 'GET', signal }, options);
};

export const getReviewControllerFindOneQueryKey = (id?: string) => {
	return [`/review/${id}`] as const;
};

export const getReviewControllerFindOneQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindOne>>,
	TError = void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindOneQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindOne>>> = ({
		signal,
	}) => reviewControllerFindOne(id, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindOne>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReviewControllerFindOneQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindOne>>
>;
export type ReviewControllerFindOneQueryError = void;

export function useReviewControllerFindOne<
	TData = Awaited<ReturnType<typeof reviewControllerFindOne>>,
	TError = void,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindOne>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindOne>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindOne>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindOne<
	TData = Awaited<ReturnType<typeof reviewControllerFindOne>>,
	TError = void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindOne>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof reviewControllerFindOne>>,
					TError,
					Awaited<ReturnType<typeof reviewControllerFindOne>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useReviewControllerFindOne<
	TData = Awaited<ReturnType<typeof reviewControllerFindOne>>,
	TError = void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get a review by ID
 */

export function useReviewControllerFindOne<
	TData = Awaited<ReturnType<typeof reviewControllerFindOne>>,
	TError = void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getReviewControllerFindOneQueryOptions(id, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update a review
 */
export const reviewControllerUpdate = (
	id: string,
	updateReviewDtoClass: UpdateReviewDtoClass,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<ReviewAggregated>(
		{
			url: `/review/${id}`,
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			data: updateReviewDtoClass,
		},
		options
	);
};

export const getReviewControllerUpdateMutationOptions = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerUpdate>>,
		TError,
		{ id: string; data: UpdateReviewDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof reviewControllerUpdate>>,
	TError,
	{ id: string; data: UpdateReviewDtoClass },
	TContext
> => {
	const mutationKey = ['reviewControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof reviewControllerUpdate>>,
		{ id: string; data: UpdateReviewDtoClass }
	> = (props) => {
		const { id, data } = props ?? {};

		return reviewControllerUpdate(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReviewControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerUpdate>>
>;
export type ReviewControllerUpdateMutationBody = UpdateReviewDtoClass;
export type ReviewControllerUpdateMutationError = void | void | void | void;

/**
 * @summary Update a review
 */
export const useReviewControllerUpdate = <TError = void | void | void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof reviewControllerUpdate>>,
			TError,
			{ id: string; data: UpdateReviewDtoClass },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof reviewControllerUpdate>>,
	TError,
	{ id: string; data: UpdateReviewDtoClass },
	TContext
> => {
	const mutationOptions = getReviewControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a review
 */
export const reviewControllerRemove = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<void>({ url: `/review/${id}`, method: 'DELETE' }, options);
};

export const getReviewControllerRemoveMutationOptions = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof reviewControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['reviewControllerRemove'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof reviewControllerRemove>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return reviewControllerRemove(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReviewControllerRemoveMutationResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerRemove>>
>;

export type ReviewControllerRemoveMutationError = void | void | void;

/**
 * @summary Delete a review
 */
export const useReviewControllerRemove = <TError = void | void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof reviewControllerRemove>>,
			TError,
			{ id: string },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof reviewControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getReviewControllerRemoveMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Update movie details from TMDB
 */
export const movieControllerUpdate = (
	tmdbId: number,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<Movie>({ url: `/movie/${tmdbId}`, method: 'PUT' }, options);
};

export const getMovieControllerUpdateMutationOptions = <
	TError = void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof movieControllerUpdate>>,
		TError,
		{ tmdbId: number },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof movieControllerUpdate>>,
	TError,
	{ tmdbId: number },
	TContext
> => {
	const mutationKey = ['movieControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof movieControllerUpdate>>,
		{ tmdbId: number }
	> = (props) => {
		const { tmdbId } = props ?? {};

		return movieControllerUpdate(tmdbId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type MovieControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof movieControllerUpdate>>
>;

export type MovieControllerUpdateMutationError = void;

/**
 * @summary Update movie details from TMDB
 */
export const useMovieControllerUpdate = <TError = void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof movieControllerUpdate>>,
			TError,
			{ tmdbId: number },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof movieControllerUpdate>>,
	TError,
	{ tmdbId: number },
	TContext
> => {
	const mutationOptions = getMovieControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get actor insights for a user
 */
export const insightControllerGetActorInsights = (
	userId: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ActorInsight[]>(
		{ url: `/insight/${userId}/actor`, method: 'GET', signal },
		options
	);
};

export const getInsightControllerGetActorInsightsQueryKey = (userId?: string) => {
	return [`/insight/${userId}/actor`] as const;
};

export const getInsightControllerGetActorInsightsQueryOptions = <
	TData = Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetActorInsights>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getInsightControllerGetActorInsightsQueryKey(userId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof insightControllerGetActorInsights>>> = ({
		signal,
	}) => insightControllerGetActorInsights(userId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type InsightControllerGetActorInsightsQueryResult = NonNullable<
	Awaited<ReturnType<typeof insightControllerGetActorInsights>>
>;
export type InsightControllerGetActorInsightsQueryError = unknown;

export function useInsightControllerGetActorInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
	TError = unknown,
>(
	userId: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetActorInsights>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
					TError,
					Awaited<ReturnType<typeof insightControllerGetActorInsights>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInsightControllerGetActorInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetActorInsights>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
					TError,
					Awaited<ReturnType<typeof insightControllerGetActorInsights>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInsightControllerGetActorInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetActorInsights>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get actor insights for a user
 */

export function useInsightControllerGetActorInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetActorInsights>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getInsightControllerGetActorInsightsQueryOptions(userId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get genre insights for a user
 */
export const insightControllerGetGenreInsights = (
	userId: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<GenreInsight>(
		{ url: `/insight/${userId}/genre`, method: 'GET', signal },
		options
	);
};

export const getInsightControllerGetGenreInsightsQueryKey = (userId?: string) => {
	return [`/insight/${userId}/genre`] as const;
};

export const getInsightControllerGetGenreInsightsQueryOptions = <
	TData = Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetGenreInsights>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getInsightControllerGetGenreInsightsQueryKey(userId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof insightControllerGetGenreInsights>>> = ({
		signal,
	}) => insightControllerGetGenreInsights(userId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type InsightControllerGetGenreInsightsQueryResult = NonNullable<
	Awaited<ReturnType<typeof insightControllerGetGenreInsights>>
>;
export type InsightControllerGetGenreInsightsQueryError = unknown;

export function useInsightControllerGetGenreInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
	TError = unknown,
>(
	userId: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetGenreInsights>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
					TError,
					Awaited<ReturnType<typeof insightControllerGetGenreInsights>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInsightControllerGetGenreInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetGenreInsights>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
					TError,
					Awaited<ReturnType<typeof insightControllerGetGenreInsights>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInsightControllerGetGenreInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetGenreInsights>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get genre insights for a user
 */

export function useInsightControllerGetGenreInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof insightControllerGetGenreInsights>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getInsightControllerGetGenreInsightsQueryOptions(userId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get review heatmap data for a user
 */
export const insightControllerGetHeatmapInsights = (
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<HeatmapInsight[]>(
		{ url: `/insight/${userId}/heatmap`, method: 'GET', params, signal },
		options
	);
};

export const getInsightControllerGetHeatmapInsightsQueryKey = (
	userId?: string,
	params?: InsightControllerGetHeatmapInsightsParams
) => {
	return [`/insight/${userId}/heatmap`, ...(params ? [params] : [])] as const;
};

export const getInsightControllerGetHeatmapInsightsQueryOptions = <
	TData = Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
	TError = unknown,
>(
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getInsightControllerGetHeatmapInsightsQueryKey(userId, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>> = ({
		signal,
	}) => insightControllerGetHeatmapInsights(userId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type InsightControllerGetHeatmapInsightsQueryResult = NonNullable<
	Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>
>;
export type InsightControllerGetHeatmapInsightsQueryError = unknown;

export function useInsightControllerGetHeatmapInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
	TError = unknown,
>(
	userId: string,
	params: undefined | InsightControllerGetHeatmapInsightsParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
					TError,
					Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInsightControllerGetHeatmapInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
	TError = unknown,
>(
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
					TError,
					Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInsightControllerGetHeatmapInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
	TError = unknown,
>(
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get review heatmap data for a user
 */

export function useInsightControllerGetHeatmapInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
	TError = unknown,
>(
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getInsightControllerGetHeatmapInsightsQueryOptions(userId, params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get user watch lists
 */
export const watchListControllerGetUserWatchLists = (
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<WatchListControllerGetUserWatchLists200>(
		{ url: `/watch-list/user/${userId}`, method: 'GET', params, signal },
		options
	);
};

export const getWatchListControllerGetUserWatchListsQueryKey = (
	userId?: string,
	params?: WatchListControllerGetUserWatchListsParams
) => {
	return [`/watch-list/user/${userId}`, ...(params ? [params] : [])] as const;
};

export const getWatchListControllerGetUserWatchListsQueryOptions = <
	TData = Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
	TError = void,
>(
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getWatchListControllerGetUserWatchListsQueryKey(userId, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>
	> = ({ signal }) => watchListControllerGetUserWatchLists(userId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WatchListControllerGetUserWatchListsQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>
>;
export type WatchListControllerGetUserWatchListsQueryError = void;

export function useWatchListControllerGetUserWatchLists<
	TData = Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
	TError = void,
>(
	userId: string,
	params: undefined | WatchListControllerGetUserWatchListsParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
					TError,
					Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchListControllerGetUserWatchLists<
	TData = Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
	TError = void,
>(
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
					TError,
					Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchListControllerGetUserWatchLists<
	TData = Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
	TError = void,
>(
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get user watch lists
 */

export function useWatchListControllerGetUserWatchLists<
	TData = Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
	TError = void,
>(
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getWatchListControllerGetUserWatchListsQueryOptions(userId, params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get a watch list by ID
 */
export const watchListControllerFindOne = (
	id: string,
	params?: WatchListControllerFindOneParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<WatchlistAggregatedDetail>(
		{ url: `/watch-list/${id}`, method: 'GET', params, signal },
		options
	);
};

export const getWatchListControllerFindOneQueryKey = (
	id?: string,
	params?: WatchListControllerFindOneParams
) => {
	return [`/watch-list/${id}`, ...(params ? [params] : [])] as const;
};

export const getWatchListControllerFindOneQueryOptions = <
	TData = Awaited<ReturnType<typeof watchListControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	params?: WatchListControllerFindOneParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchListControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getWatchListControllerFindOneQueryKey(id, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof watchListControllerFindOne>>> = ({
		signal,
	}) => watchListControllerFindOne(id, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchListControllerFindOne>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WatchListControllerFindOneQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerFindOne>>
>;
export type WatchListControllerFindOneQueryError = void | void;

export function useWatchListControllerFindOne<
	TData = Awaited<ReturnType<typeof watchListControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	params: undefined | WatchListControllerFindOneParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchListControllerFindOne>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchListControllerFindOne>>,
					TError,
					Awaited<ReturnType<typeof watchListControllerFindOne>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchListControllerFindOne<
	TData = Awaited<ReturnType<typeof watchListControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	params?: WatchListControllerFindOneParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchListControllerFindOne>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchListControllerFindOne>>,
					TError,
					Awaited<ReturnType<typeof watchListControllerFindOne>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchListControllerFindOne<
	TData = Awaited<ReturnType<typeof watchListControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	params?: WatchListControllerFindOneParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchListControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get a watch list by ID
 */

export function useWatchListControllerFindOne<
	TData = Awaited<ReturnType<typeof watchListControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	params?: WatchListControllerFindOneParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchListControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getWatchListControllerFindOneQueryOptions(id, params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update a watch list
 */
export const watchListControllerUpdate = (
	id: string,
	updateWatchListDtoClass: UpdateWatchListDtoClass,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<Watchlist>(
		{
			url: `/watch-list/${id}`,
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			data: updateWatchListDtoClass,
		},
		options
	);
};

export const getWatchListControllerUpdateMutationOptions = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerUpdate>>,
		TError,
		{ id: string; data: UpdateWatchListDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchListControllerUpdate>>,
	TError,
	{ id: string; data: UpdateWatchListDtoClass },
	TContext
> => {
	const mutationKey = ['watchListControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchListControllerUpdate>>,
		{ id: string; data: UpdateWatchListDtoClass }
	> = (props) => {
		const { id, data } = props ?? {};

		return watchListControllerUpdate(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchListControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerUpdate>>
>;
export type WatchListControllerUpdateMutationBody = UpdateWatchListDtoClass;
export type WatchListControllerUpdateMutationError = void | void | void | void;

/**
 * @summary Update a watch list
 */
export const useWatchListControllerUpdate = <
	TError = void | void | void | void,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof watchListControllerUpdate>>,
			TError,
			{ id: string; data: UpdateWatchListDtoClass },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof watchListControllerUpdate>>,
	TError,
	{ id: string; data: UpdateWatchListDtoClass },
	TContext
> => {
	const mutationOptions = getWatchListControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a watch list
 */
export const watchListControllerRemove = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<void>({ url: `/watch-list/${id}`, method: 'DELETE' }, options);
};

export const getWatchListControllerRemoveMutationOptions = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchListControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['watchListControllerRemove'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchListControllerRemove>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return watchListControllerRemove(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchListControllerRemoveMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerRemove>>
>;

export type WatchListControllerRemoveMutationError = void | void | void;

/**
 * @summary Delete a watch list
 */
export const useWatchListControllerRemove = <TError = void | void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof watchListControllerRemove>>,
			TError,
			{ id: string },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof watchListControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getWatchListControllerRemoveMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create a new watch list
 */
export const watchListControllerCreate = (
	createWatchListDtoClass: CreateWatchListDtoClass,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<Watchlist>(
		{
			url: `/watch-list`,
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			data: createWatchListDtoClass,
			signal,
		},
		options
	);
};

export const getWatchListControllerCreateMutationOptions = <
	TError = void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerCreate>>,
		TError,
		{ data: CreateWatchListDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchListControllerCreate>>,
	TError,
	{ data: CreateWatchListDtoClass },
	TContext
> => {
	const mutationKey = ['watchListControllerCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchListControllerCreate>>,
		{ data: CreateWatchListDtoClass }
	> = (props) => {
		const { data } = props ?? {};

		return watchListControllerCreate(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchListControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerCreate>>
>;
export type WatchListControllerCreateMutationBody = CreateWatchListDtoClass;
export type WatchListControllerCreateMutationError = void | void;

/**
 * @summary Create a new watch list
 */
export const useWatchListControllerCreate = <TError = void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof watchListControllerCreate>>,
			TError,
			{ data: CreateWatchListDtoClass },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof watchListControllerCreate>>,
	TError,
	{ data: CreateWatchListDtoClass },
	TContext
> => {
	const mutationOptions = getWatchListControllerCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create a new user
 */
export const userControllerCreate = (
	createUserDto: CreateUserDto,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<User>(
		{
			url: `/user`,
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			data: createUserDto,
			signal,
		},
		options
	);
};

export const getUserControllerCreateMutationOptions = <
	TError = void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerCreate>>,
		TError,
		{ data: CreateUserDto },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof userControllerCreate>>,
	TError,
	{ data: CreateUserDto },
	TContext
> => {
	const mutationKey = ['userControllerCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof userControllerCreate>>,
		{ data: CreateUserDto }
	> = (props) => {
		const { data } = props ?? {};

		return userControllerCreate(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UserControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof userControllerCreate>>
>;
export type UserControllerCreateMutationBody = CreateUserDto;
export type UserControllerCreateMutationError = void | void;

/**
 * @summary Create a new user
 */
export const useUserControllerCreate = <TError = void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof userControllerCreate>>,
			TError,
			{ data: CreateUserDto },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof userControllerCreate>>,
	TError,
	{ data: CreateUserDto },
	TContext
> => {
	const mutationOptions = getUserControllerCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all users
 */
export const userControllerFindAll = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<User[]>({ url: `/user`, method: 'GET', signal }, options);
};

export const getUserControllerFindAllQueryKey = () => {
	return [`/user`] as const;
};

export const getUserControllerFindAllQueryOptions = <
	TData = Awaited<ReturnType<typeof userControllerFindAll>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUserControllerFindAllQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindAll>>> = ({ signal }) =>
		userControllerFindAll(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof userControllerFindAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerFindAllQueryResult = NonNullable<
	Awaited<ReturnType<typeof userControllerFindAll>>
>;
export type UserControllerFindAllQueryError = unknown;

export function useUserControllerFindAll<
	TData = Awaited<ReturnType<typeof userControllerFindAll>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof userControllerFindAll>>,
					TError,
					Awaited<ReturnType<typeof userControllerFindAll>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindAll<
	TData = Awaited<ReturnType<typeof userControllerFindAll>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof userControllerFindAll>>,
					TError,
					Awaited<ReturnType<typeof userControllerFindAll>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindAll<
	TData = Awaited<ReturnType<typeof userControllerFindAll>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all users
 */

export function useUserControllerFindAll<
	TData = Awaited<ReturnType<typeof userControllerFindAll>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getUserControllerFindAllQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Check if a username is available
 */
export const userControllerIsUsernameAvailable = (
	username: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<UsernameAvailableDto>(
		{ url: `/user/username/${username}/available`, method: 'GET', signal },
		options
	);
};

export const getUserControllerIsUsernameAvailableQueryKey = (username?: string) => {
	return [`/user/username/${username}/available`] as const;
};

export const getUserControllerIsUsernameAvailableQueryOptions = <
	TData = Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
	TError = unknown,
>(
	username: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUserControllerIsUsernameAvailableQueryKey(username);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>> = ({
		signal,
	}) => userControllerIsUsernameAvailable(username, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!username, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerIsUsernameAvailableQueryResult = NonNullable<
	Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>
>;
export type UserControllerIsUsernameAvailableQueryError = unknown;

export function useUserControllerIsUsernameAvailable<
	TData = Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
	TError = unknown,
>(
	username: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
					TError,
					Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerIsUsernameAvailable<
	TData = Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
	TError = unknown,
>(
	username: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
					TError,
					Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerIsUsernameAvailable<
	TData = Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
	TError = unknown,
>(
	username: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Check if a username is available
 */

export function useUserControllerIsUsernameAvailable<
	TData = Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>,
	TError = unknown,
>(
	username: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerIsUsernameAvailable>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getUserControllerIsUsernameAvailableQueryOptions(username, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get a user by ID or Firebase UUID
 */
export const userControllerFindOne = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<UserProfileWithWatchedCount>(
		{ url: `/user/${id}`, method: 'GET', signal },
		options
	);
};

export const getUserControllerFindOneQueryKey = (id?: string) => {
	return [`/user/${id}`] as const;
};

export const getUserControllerFindOneQueryOptions = <
	TData = Awaited<ReturnType<typeof userControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUserControllerFindOneQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindOne>>> = ({ signal }) =>
		userControllerFindOne(id, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof userControllerFindOne>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerFindOneQueryResult = NonNullable<
	Awaited<ReturnType<typeof userControllerFindOne>>
>;
export type UserControllerFindOneQueryError = void | void;

export function useUserControllerFindOne<
	TData = Awaited<ReturnType<typeof userControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof userControllerFindOne>>,
					TError,
					Awaited<ReturnType<typeof userControllerFindOne>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
	TData = Awaited<ReturnType<typeof userControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof userControllerFindOne>>,
					TError,
					Awaited<ReturnType<typeof userControllerFindOne>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
	TData = Awaited<ReturnType<typeof userControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get a user by ID or Firebase UUID
 */

export function useUserControllerFindOne<
	TData = Awaited<ReturnType<typeof userControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getUserControllerFindOneQueryOptions(id, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update a user
 */
export const userControllerUpdate = (
	id: string,
	updateUserDto: UpdateUserDto,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<User>(
		{
			url: `/user/${id}`,
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			data: updateUserDto,
		},
		options
	);
};

export const getUserControllerUpdateMutationOptions = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerUpdate>>,
		TError,
		{ id: string; data: UpdateUserDto },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof userControllerUpdate>>,
	TError,
	{ id: string; data: UpdateUserDto },
	TContext
> => {
	const mutationKey = ['userControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof userControllerUpdate>>,
		{ id: string; data: UpdateUserDto }
	> = (props) => {
		const { id, data } = props ?? {};

		return userControllerUpdate(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UserControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof userControllerUpdate>>
>;
export type UserControllerUpdateMutationBody = UpdateUserDto;
export type UserControllerUpdateMutationError = void | void | void | void;

/**
 * @summary Update a user
 */
export const useUserControllerUpdate = <TError = void | void | void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof userControllerUpdate>>,
			TError,
			{ id: string; data: UpdateUserDto },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof userControllerUpdate>>,
	TError,
	{ id: string; data: UpdateUserDto },
	TContext
> => {
	const mutationOptions = getUserControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a user
 */
export const userControllerRemove = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<void>({ url: `/user/${id}`, method: 'DELETE' }, options);
};

export const getUserControllerRemoveMutationOptions = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof userControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['userControllerRemove'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof userControllerRemove>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return userControllerRemove(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UserControllerRemoveMutationResult = NonNullable<
	Awaited<ReturnType<typeof userControllerRemove>>
>;

export type UserControllerRemoveMutationError = void | void | void;

/**
 * @summary Delete a user
 */
export const useUserControllerRemove = <TError = void | void | void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof userControllerRemove>>,
			TError,
			{ id: string },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof userControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getUserControllerRemoveMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get movie watched stats (likes/dislikes)
 */
export const watchedControllerGetMovieStats = (
	tmdbId: number,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<MovieWatchedStatsDto>(
		{ url: `/watched/movie/${tmdbId}/stats`, method: 'GET', signal },
		options
	);
};

export const getWatchedControllerGetMovieStatsQueryKey = (tmdbId?: number) => {
	return [`/watched/movie/${tmdbId}/stats`] as const;
};

export const getWatchedControllerGetMovieStatsQueryOptions = <
	TData = Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetMovieStats>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getWatchedControllerGetMovieStatsQueryKey(tmdbId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof watchedControllerGetMovieStats>>> = ({
		signal,
	}) => watchedControllerGetMovieStats(tmdbId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!tmdbId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WatchedControllerGetMovieStatsQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerGetMovieStats>>
>;
export type WatchedControllerGetMovieStatsQueryError = unknown;

export function useWatchedControllerGetMovieStats<
	TData = Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
	TError = unknown,
>(
	tmdbId: number,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetMovieStats>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerGetMovieStats>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerGetMovieStats<
	TData = Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetMovieStats>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerGetMovieStats>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerGetMovieStats<
	TData = Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetMovieStats>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get movie watched stats (likes/dislikes)
 */

export function useWatchedControllerGetMovieStats<
	TData = Awaited<ReturnType<typeof watchedControllerGetMovieStats>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetMovieStats>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getWatchedControllerGetMovieStatsQueryOptions(tmdbId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get current user watched status for a movie
 */
export const watchedControllerGetWatchedStatus = (
	tmdbId: number,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<WatchedStatusDto>(
		{ url: `/watched/movie/${tmdbId}/status`, method: 'GET', signal },
		options
	);
};

export const getWatchedControllerGetWatchedStatusQueryKey = (tmdbId?: number) => {
	return [`/watched/movie/${tmdbId}/status`] as const;
};

export const getWatchedControllerGetWatchedStatusQueryOptions = <
	TData = Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getWatchedControllerGetWatchedStatusQueryKey(tmdbId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>> = ({
		signal,
	}) => watchedControllerGetWatchedStatus(tmdbId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!tmdbId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WatchedControllerGetWatchedStatusQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>
>;
export type WatchedControllerGetWatchedStatusQueryError = unknown;

export function useWatchedControllerGetWatchedStatus<
	TData = Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
	TError = unknown,
>(
	tmdbId: number,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerGetWatchedStatus<
	TData = Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerGetWatchedStatus<
	TData = Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get current user watched status for a movie
 */

export function useWatchedControllerGetWatchedStatus<
	TData = Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>,
	TError = unknown,
>(
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerGetWatchedStatus>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getWatchedControllerGetWatchedStatusQueryOptions(tmdbId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get user's watched history
 */
export const watchedControllerFindByUserId = (
	userId: string,
	params?: WatchedControllerFindByUserIdParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<WatchedControllerFindByUserId200>(
		{ url: `/watched/${userId}`, method: 'GET', params, signal },
		options
	);
};

export const getWatchedControllerFindByUserIdQueryKey = (
	userId?: string,
	params?: WatchedControllerFindByUserIdParams
) => {
	return [`/watched/${userId}`, ...(params ? [params] : [])] as const;
};

export const getWatchedControllerFindByUserIdQueryOptions = <
	TData = Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: WatchedControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerFindByUserId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getWatchedControllerFindByUserIdQueryKey(userId, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof watchedControllerFindByUserId>>> = ({
		signal,
	}) => watchedControllerFindByUserId(userId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WatchedControllerFindByUserIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerFindByUserId>>
>;
export type WatchedControllerFindByUserIdQueryError = unknown;

export function useWatchedControllerFindByUserId<
	TData = Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params: undefined | WatchedControllerFindByUserIdParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerFindByUserId>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerFindByUserId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerFindByUserId<
	TData = Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: WatchedControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerFindByUserId>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerFindByUserId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerFindByUserId<
	TData = Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: WatchedControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerFindByUserId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get user's watched history
 */

export function useWatchedControllerFindByUserId<
	TData = Awaited<ReturnType<typeof watchedControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: WatchedControllerFindByUserIdParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof watchedControllerFindByUserId>>, TError, TData>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getWatchedControllerFindByUserIdQueryOptions(userId, params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Check single watched item
 */
export const watchedControllerFindOneByUserAndTmdbId = (
	userId: string,
	tmdbId: number,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<WatchedAggregated>(
		{ url: `/watched/${userId}/${tmdbId}`, method: 'GET', signal },
		options
	);
};

export const getWatchedControllerFindOneByUserAndTmdbIdQueryKey = (
	userId?: string,
	tmdbId?: number
) => {
	return [`/watched/${userId}/${tmdbId}`] as const;
};

export const getWatchedControllerFindOneByUserAndTmdbIdQueryOptions = <
	TData = Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
	TError = void,
>(
	userId: string,
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getWatchedControllerFindOneByUserAndTmdbIdQueryKey(userId, tmdbId);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>
	> = ({ signal }) =>
		watchedControllerFindOneByUserAndTmdbId(userId, tmdbId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!(userId && tmdbId), ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type WatchedControllerFindOneByUserAndTmdbIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>
>;
export type WatchedControllerFindOneByUserAndTmdbIdQueryError = void;

export function useWatchedControllerFindOneByUserAndTmdbId<
	TData = Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
	TError = void,
>(
	userId: string,
	tmdbId: number,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerFindOneByUserAndTmdbId<
	TData = Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
	TError = void,
>(
	userId: string,
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
					TError,
					Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>
				>,
				'initialData'
			>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useWatchedControllerFindOneByUserAndTmdbId<
	TData = Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
	TError = void,
>(
	userId: string,
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Check single watched item
 */

export function useWatchedControllerFindOneByUserAndTmdbId<
	TData = Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
	TError = void,
>(
	userId: string,
	tmdbId: number,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof watchedControllerFindOneByUserAndTmdbId>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getWatchedControllerFindOneByUserAndTmdbIdQueryOptions(
		userId,
		tmdbId,
		options
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Mark movie as watched
 */
export const watchedControllerCreate = (
	createWatchedDtoClass: CreateWatchedDtoClass,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<WatchedAggregated>(
		{
			url: `/watched`,
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			data: createWatchedDtoClass,
			signal,
		},
		options
	);
};

export const getWatchedControllerCreateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchedControllerCreate>>,
		TError,
		{ data: CreateWatchedDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchedControllerCreate>>,
	TError,
	{ data: CreateWatchedDtoClass },
	TContext
> => {
	const mutationKey = ['watchedControllerCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchedControllerCreate>>,
		{ data: CreateWatchedDtoClass }
	> = (props) => {
		const { data } = props ?? {};

		return watchedControllerCreate(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchedControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerCreate>>
>;
export type WatchedControllerCreateMutationBody = CreateWatchedDtoClass;
export type WatchedControllerCreateMutationError = unknown;

/**
 * @summary Mark movie as watched
 */
export const useWatchedControllerCreate = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof watchedControllerCreate>>,
			TError,
			{ data: CreateWatchedDtoClass },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof watchedControllerCreate>>,
	TError,
	{ data: CreateWatchedDtoClass },
	TContext
> => {
	const mutationOptions = getWatchedControllerCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Update watched item
 */
export const watchedControllerUpdate = (
	id: string,
	updateWatchedDtoClass: UpdateWatchedDtoClass,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<WatchedAggregated>(
		{
			url: `/watched/${id}`,
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			data: updateWatchedDtoClass,
		},
		options
	);
};

export const getWatchedControllerUpdateMutationOptions = <
	TError = void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchedControllerUpdate>>,
		TError,
		{ id: string; data: UpdateWatchedDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchedControllerUpdate>>,
	TError,
	{ id: string; data: UpdateWatchedDtoClass },
	TContext
> => {
	const mutationKey = ['watchedControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchedControllerUpdate>>,
		{ id: string; data: UpdateWatchedDtoClass }
	> = (props) => {
		const { id, data } = props ?? {};

		return watchedControllerUpdate(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchedControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerUpdate>>
>;
export type WatchedControllerUpdateMutationBody = UpdateWatchedDtoClass;
export type WatchedControllerUpdateMutationError = void;

/**
 * @summary Update watched item
 */
export const useWatchedControllerUpdate = <TError = void, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof watchedControllerUpdate>>,
			TError,
			{ id: string; data: UpdateWatchedDtoClass },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof watchedControllerUpdate>>,
	TError,
	{ id: string; data: UpdateWatchedDtoClass },
	TContext
> => {
	const mutationOptions = getWatchedControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Remove from watched
 */
export const watchedControllerRemove = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<void>({ url: `/watched/${id}`, method: 'DELETE' }, options);
};

export const getWatchedControllerRemoveMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchedControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchedControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['watchedControllerRemove'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchedControllerRemove>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return watchedControllerRemove(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchedControllerRemoveMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerRemove>>
>;

export type WatchedControllerRemoveMutationError = unknown;

/**
 * @summary Remove from watched
 */
export const useWatchedControllerRemove = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof watchedControllerRemove>>,
			TError,
			{ id: string },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof watchedControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getWatchedControllerRemoveMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Batch mark as watched
 */
export const watchedControllerBatchCreate = (
	batchWatchedDtoClass: BatchWatchedDtoClass,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<void>(
		{
			url: `/watched/batch`,
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			data: batchWatchedDtoClass,
			signal,
		},
		options
	);
};

export const getWatchedControllerBatchCreateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchedControllerBatchCreate>>,
		TError,
		{ data: BatchWatchedDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchedControllerBatchCreate>>,
	TError,
	{ data: BatchWatchedDtoClass },
	TContext
> => {
	const mutationKey = ['watchedControllerBatchCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchedControllerBatchCreate>>,
		{ data: BatchWatchedDtoClass }
	> = (props) => {
		const { data } = props ?? {};

		return watchedControllerBatchCreate(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchedControllerBatchCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchedControllerBatchCreate>>
>;
export type WatchedControllerBatchCreateMutationBody = BatchWatchedDtoClass;
export type WatchedControllerBatchCreateMutationError = unknown;

/**
 * @summary Batch mark as watched
 */
export const useWatchedControllerBatchCreate = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof watchedControllerBatchCreate>>,
			TError,
			{ data: BatchWatchedDtoClass },
			TContext
		>;
		request?: SecondParameter<typeof axiosInstance>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<typeof watchedControllerBatchCreate>>,
	TError,
	{ data: BatchWatchedDtoClass },
	TContext
> => {
	const mutationOptions = getWatchedControllerBatchCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
