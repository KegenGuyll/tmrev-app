/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * TMREV API v2
 * Review aggregation and movie database API
 * OpenAPI spec version: 2.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
	MutationFunction,
	QueryFunction,
	QueryKey,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from '@tanstack/react-query';

import type {
	ActorInsight,
	CreateReviewDtoClass,
	CreateUserDto,
	GenreInsight,
	HeatmapInsight,
	InsightControllerGetHeatmapInsightsParams,
	Movie,
	ReviewAggregated,
	ReviewControllerFindByTmdbId200,
	ReviewControllerFindByTmdbIdParams,
	ReviewControllerFindByUserId200,
	ReviewControllerFindByUserIdParams,
	ReviewControllerFindMostReviewedV2200Item,
	UpdateReviewDtoClass,
	UpdateUserDto,
	User,
	UserProfile,
	WatchListControllerGetUserWatchLists200,
	WatchListControllerGetUserWatchListsParams,
	Watchlist,
} from './schemas';

import { axiosInstance } from './mutator/axiosInstance';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const appControllerGetHello = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<void>({ url: `/`, method: 'GET', signal }, options);
};

export const getAppControllerGetHelloQueryKey = () => {
	return [`/`] as const;
};

export const getAppControllerGetHelloQueryOptions = <
	TData = Awaited<ReturnType<typeof appControllerGetHello>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) =>
		appControllerGetHello(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof appControllerGetHello>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type AppControllerGetHelloQueryResult = NonNullable<
	Awaited<ReturnType<typeof appControllerGetHello>>
>;
export type AppControllerGetHelloQueryError = unknown;

export function useAppControllerGetHello<
	TData = Awaited<ReturnType<typeof appControllerGetHello>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getAppControllerGetHelloQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get recently reviewed movies
 */
export const reviewControllerFindRecentlyReviewed = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated[]>(
		{ url: `/review/recently-reviewed`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindRecentlyReviewedQueryKey = () => {
	return [`/review/recently-reviewed`] as const;
};

export const getReviewControllerFindRecentlyReviewedQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindRecentlyReviewedQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>
	> = ({ signal }) => reviewControllerFindRecentlyReviewed(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type ReviewControllerFindRecentlyReviewedQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>
>;
export type ReviewControllerFindRecentlyReviewedQueryError = unknown;

/**
 * @summary Get recently reviewed movies
 */

export function useReviewControllerFindRecentlyReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindRecentlyReviewed>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getReviewControllerFindRecentlyReviewedQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get most reviewed movies
 */
export const reviewControllerFindMostReviewed = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated[]>(
		{ url: `/review/most-reviewed`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindMostReviewedQueryKey = () => {
	return [`/review/most-reviewed`] as const;
};

export const getReviewControllerFindMostReviewedQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindMostReviewedQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>> = ({
		signal,
	}) => reviewControllerFindMostReviewed(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type ReviewControllerFindMostReviewedQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>
>;
export type ReviewControllerFindMostReviewedQueryError = unknown;

/**
 * @summary Get most reviewed movies
 */

export function useReviewControllerFindMostReviewed<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewed>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getReviewControllerFindMostReviewedQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Returns the top 10 most reviewed movies with complete review, profile, and movie details. Includes a count of how many times each movie has been reviewed.
 * @summary Get most reviewed movies with full details (v2)
 */
export const reviewControllerFindMostReviewedV2 = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewControllerFindMostReviewedV2200Item[]>(
		{ url: `/review/most-reviewed/v2`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindMostReviewedV2QueryKey = () => {
	return [`/review/most-reviewed/v2`] as const;
};

export const getReviewControllerFindMostReviewedV2QueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindMostReviewedV2QueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>> = ({
		signal,
	}) => reviewControllerFindMostReviewedV2(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type ReviewControllerFindMostReviewedV2QueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>
>;
export type ReviewControllerFindMostReviewedV2QueryError = unknown;

/**
 * @summary Get most reviewed movies with full details (v2)
 */

export function useReviewControllerFindMostReviewedV2<
	TData = Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindMostReviewedV2>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getReviewControllerFindMostReviewedV2QueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Create a new review
 */
export const reviewControllerCreate = (
	createReviewDtoClass: CreateReviewDtoClass,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated>(
		{
			url: `/review`,
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			data: createReviewDtoClass,
			signal,
		},
		options
	);
};

export const getReviewControllerCreateMutationOptions = <
	TError = void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerCreate>>,
		TError,
		{ data: CreateReviewDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof reviewControllerCreate>>,
	TError,
	{ data: CreateReviewDtoClass },
	TContext
> => {
	const mutationKey = ['reviewControllerCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof reviewControllerCreate>>,
		{ data: CreateReviewDtoClass }
	> = (props) => {
		const { data } = props ?? {};

		return reviewControllerCreate(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReviewControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerCreate>>
>;
export type ReviewControllerCreateMutationBody = CreateReviewDtoClass;
export type ReviewControllerCreateMutationError = void | void;

/**
 * @summary Create a new review
 */
export const useReviewControllerCreate = <TError = void | void, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerCreate>>,
		TError,
		{ data: CreateReviewDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof reviewControllerCreate>>,
	TError,
	{ data: CreateReviewDtoClass },
	TContext
> => {
	const mutationOptions = getReviewControllerCreateMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Get reviews by TMDB movie ID
 */
export const reviewControllerFindByTmdbId = (
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewControllerFindByTmdbId200>(
		{ url: `/review/tmdb/${tmdbId}`, method: 'GET', params, signal },
		options
	);
};

export const getReviewControllerFindByTmdbIdQueryKey = (
	tmdbId?: number,
	params?: ReviewControllerFindByTmdbIdParams
) => {
	return [`/review/tmdb/${tmdbId}`, ...(params ? [params] : [])] as const;
};

export const getReviewControllerFindByTmdbIdQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
	TError = unknown,
>(
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReviewControllerFindByTmdbIdQueryKey(tmdbId, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>> = ({
		signal,
	}) => reviewControllerFindByTmdbId(tmdbId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!tmdbId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type ReviewControllerFindByTmdbIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>
>;
export type ReviewControllerFindByTmdbIdQueryError = unknown;

/**
 * @summary Get reviews by TMDB movie ID
 */

export function useReviewControllerFindByTmdbId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
	TError = unknown,
>(
	tmdbId: number,
	params?: ReviewControllerFindByTmdbIdParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof reviewControllerFindByTmdbId>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getReviewControllerFindByTmdbIdQueryOptions(tmdbId, params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get reviews by user ID
 */
export const reviewControllerFindByUserId = (
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewControllerFindByUserId200>(
		{ url: `/review/user/${userId}`, method: 'GET', params, signal },
		options
	);
};

export const getReviewControllerFindByUserIdQueryKey = (
	userId?: string,
	params?: ReviewControllerFindByUserIdParams
) => {
	return [`/review/user/${userId}`, ...(params ? [params] : [])] as const;
};

export const getReviewControllerFindByUserIdQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReviewControllerFindByUserIdQueryKey(userId, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindByUserId>>> = ({
		signal,
	}) => reviewControllerFindByUserId(userId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type ReviewControllerFindByUserIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindByUserId>>
>;
export type ReviewControllerFindByUserIdQueryError = unknown;

/**
 * @summary Get reviews by user ID
 */

export function useReviewControllerFindByUserId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
	TError = unknown,
>(
	userId: string,
	params?: ReviewControllerFindByUserIdParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof reviewControllerFindByUserId>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getReviewControllerFindByUserIdQueryOptions(userId, params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get reviews by user ID and actor ID
 */
export const reviewControllerFindByActorId = (
	userId: string,
	actorId: number,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated[]>(
		{ url: `/review/user/${userId}/actor/${actorId}`, method: 'GET', signal },
		options
	);
};

export const getReviewControllerFindByActorIdQueryKey = (userId?: string, actorId?: number) => {
	return [`/review/user/${userId}/actor/${actorId}`] as const;
};

export const getReviewControllerFindByActorIdQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
	TError = void,
>(
	userId: string,
	actorId: number,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReviewControllerFindByActorIdQueryKey(userId, actorId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindByActorId>>> = ({
		signal,
	}) => reviewControllerFindByActorId(userId, actorId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!(userId && actorId), ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type ReviewControllerFindByActorIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindByActorId>>
>;
export type ReviewControllerFindByActorIdQueryError = void;

/**
 * @summary Get reviews by user ID and actor ID
 */

export function useReviewControllerFindByActorId<
	TData = Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
	TError = void,
>(
	userId: string,
	actorId: number,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof reviewControllerFindByActorId>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getReviewControllerFindByActorIdQueryOptions(userId, actorId, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get a review by ID
 */
export const reviewControllerFindOne = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ReviewAggregated>({ url: `/review/${id}`, method: 'GET', signal }, options);
};

export const getReviewControllerFindOneQueryKey = (id?: string) => {
	return [`/review/${id}`] as const;
};

export const getReviewControllerFindOneQueryOptions = <
	TData = Awaited<ReturnType<typeof reviewControllerFindOne>>,
	TError = void,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindOne>>, TError, TData>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getReviewControllerFindOneQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof reviewControllerFindOne>>> = ({
		signal,
	}) => reviewControllerFindOne(id, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof reviewControllerFindOne>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type ReviewControllerFindOneQueryResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerFindOne>>
>;
export type ReviewControllerFindOneQueryError = void;

/**
 * @summary Get a review by ID
 */

export function useReviewControllerFindOne<
	TData = Awaited<ReturnType<typeof reviewControllerFindOne>>,
	TError = void,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof reviewControllerFindOne>>, TError, TData>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getReviewControllerFindOneQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update a review
 */
export const reviewControllerUpdate = (
	id: string,
	updateReviewDtoClass: UpdateReviewDtoClass,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<ReviewAggregated>(
		{
			url: `/review/${id}`,
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			data: updateReviewDtoClass,
		},
		options
	);
};

export const getReviewControllerUpdateMutationOptions = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerUpdate>>,
		TError,
		{ id: string; data: UpdateReviewDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof reviewControllerUpdate>>,
	TError,
	{ id: string; data: UpdateReviewDtoClass },
	TContext
> => {
	const mutationKey = ['reviewControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof reviewControllerUpdate>>,
		{ id: string; data: UpdateReviewDtoClass }
	> = (props) => {
		const { id, data } = props ?? {};

		return reviewControllerUpdate(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReviewControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerUpdate>>
>;
export type ReviewControllerUpdateMutationBody = UpdateReviewDtoClass;
export type ReviewControllerUpdateMutationError = void | void | void | void;

/**
 * @summary Update a review
 */
export const useReviewControllerUpdate = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerUpdate>>,
		TError,
		{ id: string; data: UpdateReviewDtoClass },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof reviewControllerUpdate>>,
	TError,
	{ id: string; data: UpdateReviewDtoClass },
	TContext
> => {
	const mutationOptions = getReviewControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Delete a review
 */
export const reviewControllerRemove = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<void>({ url: `/review/${id}`, method: 'DELETE' }, options);
};

export const getReviewControllerRemoveMutationOptions = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof reviewControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['reviewControllerRemove'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof reviewControllerRemove>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return reviewControllerRemove(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReviewControllerRemoveMutationResult = NonNullable<
	Awaited<ReturnType<typeof reviewControllerRemove>>
>;

export type ReviewControllerRemoveMutationError = void | void | void;

/**
 * @summary Delete a review
 */
export const useReviewControllerRemove = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof reviewControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof reviewControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getReviewControllerRemoveMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Update movie details from TMDB
 */
export const movieControllerUpdate = (
	tmdbId: number,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<Movie>({ url: `/movie/${tmdbId}`, method: 'PUT' }, options);
};

export const getMovieControllerUpdateMutationOptions = <
	TError = void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof movieControllerUpdate>>,
		TError,
		{ tmdbId: number },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof movieControllerUpdate>>,
	TError,
	{ tmdbId: number },
	TContext
> => {
	const mutationKey = ['movieControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof movieControllerUpdate>>,
		{ tmdbId: number }
	> = (props) => {
		const { tmdbId } = props ?? {};

		return movieControllerUpdate(tmdbId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type MovieControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof movieControllerUpdate>>
>;

export type MovieControllerUpdateMutationError = void;

/**
 * @summary Update movie details from TMDB
 */
export const useMovieControllerUpdate = <TError = void, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof movieControllerUpdate>>,
		TError,
		{ tmdbId: number },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof movieControllerUpdate>>,
	TError,
	{ tmdbId: number },
	TContext
> => {
	const mutationOptions = getMovieControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Get actor insights for a user
 */
export const insightControllerGetActorInsights = (
	userId: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<ActorInsight[]>(
		{ url: `/insight/${userId}/actor`, method: 'GET', signal },
		options
	);
};

export const getInsightControllerGetActorInsightsQueryKey = (userId?: string) => {
	return [`/insight/${userId}/actor`] as const;
};

export const getInsightControllerGetActorInsightsQueryOptions = <
	TData = Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getInsightControllerGetActorInsightsQueryKey(userId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof insightControllerGetActorInsights>>> = ({
		signal,
	}) => insightControllerGetActorInsights(userId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type InsightControllerGetActorInsightsQueryResult = NonNullable<
	Awaited<ReturnType<typeof insightControllerGetActorInsights>>
>;
export type InsightControllerGetActorInsightsQueryError = unknown;

/**
 * @summary Get actor insights for a user
 */

export function useInsightControllerGetActorInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof insightControllerGetActorInsights>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getInsightControllerGetActorInsightsQueryOptions(userId, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get genre insights for a user
 */
export const insightControllerGetGenreInsights = (
	userId: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<GenreInsight>(
		{ url: `/insight/${userId}/genre`, method: 'GET', signal },
		options
	);
};

export const getInsightControllerGetGenreInsightsQueryKey = (userId?: string) => {
	return [`/insight/${userId}/genre`] as const;
};

export const getInsightControllerGetGenreInsightsQueryOptions = <
	TData = Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getInsightControllerGetGenreInsightsQueryKey(userId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof insightControllerGetGenreInsights>>> = ({
		signal,
	}) => insightControllerGetGenreInsights(userId, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type InsightControllerGetGenreInsightsQueryResult = NonNullable<
	Awaited<ReturnType<typeof insightControllerGetGenreInsights>>
>;
export type InsightControllerGetGenreInsightsQueryError = unknown;

/**
 * @summary Get genre insights for a user
 */

export function useInsightControllerGetGenreInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
	TError = unknown,
>(
	userId: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof insightControllerGetGenreInsights>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getInsightControllerGetGenreInsightsQueryOptions(userId, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get review heatmap data for a user
 */
export const insightControllerGetHeatmapInsights = (
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<HeatmapInsight[]>(
		{ url: `/insight/${userId}/heatmap`, method: 'GET', params, signal },
		options
	);
};

export const getInsightControllerGetHeatmapInsightsQueryKey = (
	userId?: string,
	params?: InsightControllerGetHeatmapInsightsParams
) => {
	return [`/insight/${userId}/heatmap`, ...(params ? [params] : [])] as const;
};

export const getInsightControllerGetHeatmapInsightsQueryOptions = <
	TData = Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
	TError = unknown,
>(
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getInsightControllerGetHeatmapInsightsQueryKey(userId, params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>> = ({
		signal,
	}) => insightControllerGetHeatmapInsights(userId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type InsightControllerGetHeatmapInsightsQueryResult = NonNullable<
	Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>
>;
export type InsightControllerGetHeatmapInsightsQueryError = unknown;

/**
 * @summary Get review heatmap data for a user
 */

export function useInsightControllerGetHeatmapInsights<
	TData = Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
	TError = unknown,
>(
	userId: string,
	params?: InsightControllerGetHeatmapInsightsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof insightControllerGetHeatmapInsights>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getInsightControllerGetHeatmapInsightsQueryOptions(userId, params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get user watch lists
 */
export const watchListControllerGetUserWatchLists = (
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<WatchListControllerGetUserWatchLists200>(
		{ url: `/watch-list/user/${userId}`, method: 'GET', params, signal },
		options
	);
};

export const getWatchListControllerGetUserWatchListsQueryKey = (
	userId?: string,
	params?: WatchListControllerGetUserWatchListsParams
) => {
	return [`/watch-list/user/${userId}`, ...(params ? [params] : [])] as const;
};

export const getWatchListControllerGetUserWatchListsQueryOptions = <
	TData = Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
	TError = void,
>(
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getWatchListControllerGetUserWatchListsQueryKey(userId, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>
	> = ({ signal }) => watchListControllerGetUserWatchLists(userId, params, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type WatchListControllerGetUserWatchListsQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>
>;
export type WatchListControllerGetUserWatchListsQueryError = void;

/**
 * @summary Get user watch lists
 */

export function useWatchListControllerGetUserWatchLists<
	TData = Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
	TError = void,
>(
	userId: string,
	params?: WatchListControllerGetUserWatchListsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof watchListControllerGetUserWatchLists>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getWatchListControllerGetUserWatchListsQueryOptions(userId, params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get a watch list by ID
 */
export const watchListControllerFindOne = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<Watchlist>({ url: `/watch-list/${id}`, method: 'GET', signal }, options);
};

export const getWatchListControllerFindOneQueryKey = (id?: string) => {
	return [`/watch-list/${id}`] as const;
};

export const getWatchListControllerFindOneQueryOptions = <
	TData = Awaited<ReturnType<typeof watchListControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof watchListControllerFindOne>>, TError, TData>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getWatchListControllerFindOneQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof watchListControllerFindOne>>> = ({
		signal,
	}) => watchListControllerFindOne(id, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof watchListControllerFindOne>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type WatchListControllerFindOneQueryResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerFindOne>>
>;
export type WatchListControllerFindOneQueryError = void | void;

/**
 * @summary Get a watch list by ID
 */

export function useWatchListControllerFindOne<
	TData = Awaited<ReturnType<typeof watchListControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof watchListControllerFindOne>>, TError, TData>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getWatchListControllerFindOneQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update a watch list
 */
export const watchListControllerUpdate = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<Watchlist>({ url: `/watch-list/${id}`, method: 'PATCH' }, options);
};

export const getWatchListControllerUpdateMutationOptions = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerUpdate>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchListControllerUpdate>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['watchListControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchListControllerUpdate>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return watchListControllerUpdate(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchListControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerUpdate>>
>;

export type WatchListControllerUpdateMutationError = void | void | void | void;

/**
 * @summary Update a watch list
 */
export const useWatchListControllerUpdate = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerUpdate>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof watchListControllerUpdate>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getWatchListControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Delete a watch list
 */
export const watchListControllerRemove = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<void>({ url: `/watch-list/${id}`, method: 'DELETE' }, options);
};

export const getWatchListControllerRemoveMutationOptions = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchListControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['watchListControllerRemove'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchListControllerRemove>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return watchListControllerRemove(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchListControllerRemoveMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerRemove>>
>;

export type WatchListControllerRemoveMutationError = void | void | void;

/**
 * @summary Delete a watch list
 */
export const useWatchListControllerRemove = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof watchListControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getWatchListControllerRemoveMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Create a new watch list
 */
export const watchListControllerCreate = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<Watchlist>({ url: `/watch-list`, method: 'POST', signal }, options);
};

export const getWatchListControllerCreateMutationOptions = <
	TError = void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerCreate>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof watchListControllerCreate>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ['watchListControllerCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof watchListControllerCreate>>,
		void
	> = () => {
		return watchListControllerCreate(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WatchListControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof watchListControllerCreate>>
>;

export type WatchListControllerCreateMutationError = void | void;

/**
 * @summary Create a new watch list
 */
export const useWatchListControllerCreate = <TError = void | void, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof watchListControllerCreate>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof watchListControllerCreate>>,
	TError,
	void,
	TContext
> => {
	const mutationOptions = getWatchListControllerCreateMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Create a new user
 */
export const userControllerCreate = (
	createUserDto: CreateUserDto,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<User>(
		{
			url: `/user`,
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			data: createUserDto,
			signal,
		},
		options
	);
};

export const getUserControllerCreateMutationOptions = <
	TError = void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerCreate>>,
		TError,
		{ data: CreateUserDto },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof userControllerCreate>>,
	TError,
	{ data: CreateUserDto },
	TContext
> => {
	const mutationKey = ['userControllerCreate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof userControllerCreate>>,
		{ data: CreateUserDto }
	> = (props) => {
		const { data } = props ?? {};

		return userControllerCreate(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UserControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof userControllerCreate>>
>;
export type UserControllerCreateMutationBody = CreateUserDto;
export type UserControllerCreateMutationError = void | void;

/**
 * @summary Create a new user
 */
export const useUserControllerCreate = <TError = void | void, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerCreate>>,
		TError,
		{ data: CreateUserDto },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof userControllerCreate>>,
	TError,
	{ data: CreateUserDto },
	TContext
> => {
	const mutationOptions = getUserControllerCreateMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Get all users
 */
export const userControllerFindAll = (
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<User[]>({ url: `/user`, method: 'GET', signal }, options);
};

export const getUserControllerFindAllQueryKey = () => {
	return [`/user`] as const;
};

export const getUserControllerFindAllQueryOptions = <
	TData = Awaited<ReturnType<typeof userControllerFindAll>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>;
	request?: SecondParameter<typeof axiosInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUserControllerFindAllQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindAll>>> = ({ signal }) =>
		userControllerFindAll(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof userControllerFindAll>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type UserControllerFindAllQueryResult = NonNullable<
	Awaited<ReturnType<typeof userControllerFindAll>>
>;
export type UserControllerFindAllQueryError = unknown;

/**
 * @summary Get all users
 */

export function useUserControllerFindAll<
	TData = Awaited<ReturnType<typeof userControllerFindAll>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getUserControllerFindAllQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get a user by ID or Firebase UUID
 */
export const userControllerFindOne = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>,
	signal?: AbortSignal
) => {
	return axiosInstance<UserProfile>({ url: `/user/${id}`, method: 'GET', signal }, options);
};

export const getUserControllerFindOneQueryKey = (id?: string) => {
	return [`/user/${id}`] as const;
};

export const getUserControllerFindOneQueryOptions = <
	TData = Awaited<ReturnType<typeof userControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>;
		request?: SecondParameter<typeof axiosInstance>;
	}
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUserControllerFindOneQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindOne>>> = ({ signal }) =>
		userControllerFindOne(id, requestOptions, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof userControllerFindOne>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type UserControllerFindOneQueryResult = NonNullable<
	Awaited<ReturnType<typeof userControllerFindOne>>
>;
export type UserControllerFindOneQueryError = void | void;

/**
 * @summary Get a user by ID or Firebase UUID
 */

export function useUserControllerFindOne<
	TData = Awaited<ReturnType<typeof userControllerFindOne>>,
	TError = void | void,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>;
		request?: SecondParameter<typeof axiosInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getUserControllerFindOneQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update a user
 */
export const userControllerUpdate = (
	id: string,
	updateUserDto: UpdateUserDto,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<User>(
		{
			url: `/user/${id}`,
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			data: updateUserDto,
		},
		options
	);
};

export const getUserControllerUpdateMutationOptions = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerUpdate>>,
		TError,
		{ id: string; data: UpdateUserDto },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof userControllerUpdate>>,
	TError,
	{ id: string; data: UpdateUserDto },
	TContext
> => {
	const mutationKey = ['userControllerUpdate'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof userControllerUpdate>>,
		{ id: string; data: UpdateUserDto }
	> = (props) => {
		const { id, data } = props ?? {};

		return userControllerUpdate(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UserControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof userControllerUpdate>>
>;
export type UserControllerUpdateMutationBody = UpdateUserDto;
export type UserControllerUpdateMutationError = void | void | void | void;

/**
 * @summary Update a user
 */
export const useUserControllerUpdate = <
	TError = void | void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerUpdate>>,
		TError,
		{ id: string; data: UpdateUserDto },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof userControllerUpdate>>,
	TError,
	{ id: string; data: UpdateUserDto },
	TContext
> => {
	const mutationOptions = getUserControllerUpdateMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Delete a user
 */
export const userControllerRemove = (
	id: string,
	options?: SecondParameter<typeof axiosInstance>
) => {
	return axiosInstance<void>({ url: `/user/${id}`, method: 'DELETE' }, options);
};

export const getUserControllerRemoveMutationOptions = <
	TError = void | void | void,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof userControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['userControllerRemove'];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof userControllerRemove>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return userControllerRemove(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UserControllerRemoveMutationResult = NonNullable<
	Awaited<ReturnType<typeof userControllerRemove>>
>;

export type UserControllerRemoveMutationError = void | void | void;

/**
 * @summary Delete a user
 */
export const useUserControllerRemove = <TError = void | void | void, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof userControllerRemove>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof axiosInstance>;
}): UseMutationResult<
	Awaited<ReturnType<typeof userControllerRemove>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getUserControllerRemoveMutationOptions(options);

	return useMutation(mutationOptions);
};
